package model.board.views;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import model.Piece;
import model.board.BoardPosition;
import model.board.ChessBoard;
import model.board.Square;
import model.enums.Color;
import model.enums.ViewDirection;

public class PawnView implements RankView {

    private static final ViewDirection[] UP_ATTACKS = { ViewDirection.RIGHT_UP, ViewDirection.LEFT_UP };
    private static final ViewDirection[] DOWN_ATTACKS = { ViewDirection.RIGHT_DOWN, ViewDirection.LEFT_DOWN };
    private final Color color;
    private final ViewDirection pawnDirection;

    private final List<Square> moveToSquares;
    private final List<Square> squaresHoldingPiecesAttacked;
    private final List<Square> squaresHoldingPiecesDefended;
    private final ChessBoard chessBoard;
    private Square viewPoint;

    public PawnView(BoardPosition boardPosition, Color viewColor) {

        this.viewPoint = boardPosition.square();
        this.pawnDirection = viewColor == Color.WHITE ? ViewDirection.UP : ViewDirection.DOWN;

        this.color = viewColor;
        this.chessBoard = boardPosition.chessBoard();

        this.moveToSquares = new ArrayList<Square>();
        this.squaresHoldingPiecesAttacked = new ArrayList<Square>();
        this.squaresHoldingPiecesDefended = new ArrayList<Square>();

        addSquaresToLists();

    }

    @Override
    public List<Square> moveToSquares() {
        return moveToSquares;
    }

    @Override
    public List<Square> squaresHoldingPiecesAttacked() {
        return squaresHoldingPiecesAttacked;
    }

    @Override
    public List<Square> squaresHoldingPiecesDefended() {
        return squaresHoldingPiecesDefended;
    }

    @Override
    public List<Square> threatenedSquares() {
        Square leftAttack = viewPoint.neighbor(pawnAttacks()[0]);
        return Arrays.asList(leftAttack, viewPoint.neighbor(pawnAttacks()[1]));
    }

    private void addSquaresToLists() {
        addMoveToSquares();

        List<Square> threatenedSquares = threatenedSquares();
        for (Square threatenedSquare : threatenedSquares) {
            Piece piece = chessBoard.pieceAt(threatenedSquare);
            Color opponentColor = color.opponentColor();

            if (piece != null && piece.color().equals(opponentColor)) {
                squaresHoldingPiecesAttacked.add(threatenedSquare);
            } else {
                squaresHoldingPiecesDefended.add(threatenedSquare);
            }
        }
    }

    private void addMoveToSquares() {
        Square forwardStep = viewPoint.neighbor(pawnDirection);
        if (chessBoard.pieceAt(forwardStep) == null) {
            moveToSquares.add(forwardStep);

            Piece thisPawn = chessBoard.pieceAt(viewPoint);
            if (thisPawn.homeSquare().equals(viewPoint)) {
                Square nextStep = forwardStep.neighbor(pawnDirection);
                if (chessBoard.pieceAt(nextStep) == null) {
                    moveToSquares.add(nextStep);
                }
            }
        }
    }

    private ViewDirection[] pawnAttacks() {
        if (ViewDirection.UP.equals(pawnDirection)) {
            return UP_ATTACKS;
        } else {
            return DOWN_ATTACKS;
        }
    }

}
